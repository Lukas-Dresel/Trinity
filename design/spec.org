#+TITLE: Tyrell Spec File Format
#+OPTIONS: toc:nil
#+OPTIONS: html-postamble:nil
#+LANGUAGE: en

This document describes in detail the input file format which the Tyrell
synthesizer recognize. 

A tyrell specification file is a text file in [[https://github.com/toml-lang/toml][TOML]] format. The file consists of
several sections whose usage will be explained in the rest of this
document. Note that all sections are optional, and the orders of the sections as
the appear in the input file does not affect how the synthesizer interprets
them.

* The ~[env]~ section

This section contains information not directly related to the synthesis task but
required for code generation. Currently the only interpreted field in this
section is the =headers= field, which must be a list that contains all headers
to include in the synthesized source code. The style of the include is
determined by whether the specified header name is surrounded with angle
bracket. For example:
#+BEGIN_SRC toml
[env]
headers = [ "myheader.h", "<stdio.h>" ]
#+END_SRC
The above specification will cause the following two lines to be added to the
beginning of the generated C code:
#+BEGIN_SRC c
#include "myheader.h"
#include <stdio.h>
#+END_SRC

* The ~[[type]]~ section
  
This section contains information of all types used by the synthesizer. From the
perspective of Tyrell, a type is a name associated with a finite set of constants (which
are collectively called the /domain/ of the type). The specification file may
contain arbitrarily many types, each of can be put into a separate
~[[type]]~ table. For example:
#+BEGIN_SRC toml
[[type]]
name = "Foo"
domain = [ "1", "2", "3" ]

[[type]]
name = "Bar"
#+END_SRC
This specification contains two types with name "Foo" and "Bar"
respectively. 

** The ~name~ field

Each Tyrell type is uniquely identified by its name. A name is simply a string
value that does not start with a dollar sign ~$~. Strings that start with ~$~
are reserved by the Tyrell tool itself. This field is mandantory.

** The ~display~ field

The ~display~ field controls how the type is shown in the synthesized code. By
default, if the user does not provide this field explicitly, then its value will
be the same as the value for the ~name~ field. Unlike the ~name~ field, the
~display~ fields of different types do not have to be all distinct. This can be
useful if we want to have different ranges for variables of the same C type. 

** The ~domain~ field

This field is a list of strings containing all possible constants that belong to the
type. If the user does not provide this field explicitly, the domain is empty by
default. An empty domain for type ~T~ means that in the synthesized code if
there is a variable of type ~T~, no constants can be assigned to this variable
(the variable can still be assigned through function returns or
pass-by-reference function arguments, though). 

Note that whatever values the user specifies here will be copied literally to the 
synthesized programs. This means that for string literal constants one might need 
to double-quote the literals:
#+BEGIN_SRC toml
[[type]]
name = "const char*"
domain = [ '"x"', '"y"', '"z"' ]
#+END_SRC

** The ~arrayBase~, ~arrayMaxLen~, and ~arrayMinLen~ field

Tyrell also supports array types. For an array type ~T[]~, the name of the base
type ~T~ can be specified via the ~arrayBase~ field, and the maximum length of
the array can be specified via the ~arrayMaxLen~ field. Those two fields must be
specified simultaneously: the Tyrell parser will reject the specification if the
user provide the value for only one of them. In addition, the mininum length of
the array can also be specified via the ~arrayMinLen~ field. By default, the
minimum length is set to zero. For an array type with base type ~T~, minimum
length ~M~, and maximum length ~N~, its user-specified ~domain~ field will be
automatically ignored, and instead the real domain becomes a list of constants
of type ~T~, where the length of the list could vary from ~M~ to ~N~ (note the
range is /inclusive/). Possible values of each element is determined by ~T~. For
example,
#+BEGIN_SRC toml
[[type]]
name = "Foo"
domain = [ 0, 1 ]

[[type]]
name = "FooArray"
arrayBase = "Foo"
arrayMaxLen = 2
#+END_SRC
The domain for type ~FooArray~ will contain the following 7 elements: ~{0,
0}~, ~{0, 1}~, ~{1, 0}~, ~{1, 1}~, ~{0}~, ~{1}~, ~{}~.

The base type of an array type must come before the array type in the
specification file. 

* The ~[[api]]~ section

This section contains information of all API functions used by the
synthesizer. From the perspective of Tyrell, a function is a name associated
with a list of parameters and optionally a return. The specification file may
contain arbitrarily many functions, each of can be put into a separate ~[[api]]~
table. For example:
#+BEGIN_SRC toml
[[api]]
name = "foo"
  [api.return]
  type = "int"

[[api]]
name = "bar"
  [[api.param]]
  type = "int"
  name = "x"
  direction = "in"
  [[api.param]]
  type = "int"
  direction = "out"
  name = "y"
#+END_SRC
This specification contains two functions with name "foo" and "bar"
respectively. The function ~foo~ has return type of ~int~ and takes no
parameters. The function ~bar~ has ~void~ return type, takes one input
parameter of type ~int~, and takes another output parameter of type
~int~. 

** The ~name~ field

Each Tyrell function is uniquely identified by its name. A name is simply a string
value that does not start with a dollar sign ~$~. Strings that start with ~$~
are reserved by the Tyrell tool itself. This field is mandantory.

** The ~display~ field

The ~display~ field controls how the type is shown in the synthesized code. By
default, if the user does not provide this field explicitly, then its value will
be the same as the value for the ~name~ field. Unlike the ~name~ field, the
~display~ fields of different functions do not have to be all distinct. This can be
useful if we want to represent overloaded functions that share the same name but
have different number or type of parameters.

** The ~[api.return]~ subsection

This is an optional section that should contain only one ~type~ field. The
absence of this section means the function has ~void~ return type. If this
sectio is present, it specifies the return type of the function.

** The ~[[api.param]]~ subsection

This subsection contains information of the parameters of the enclosing API
function. The specification file may contain arbitrarily many parameter
specifications for an API, each of can be put into a separate ~[[api.param]]~
table. 

*** The ~type~ field

This (mandantory) field specifies the type of the parameter. 

*** The ~direction~ field

This (mandantory) field specifies the direction (input or output) of the
parameter. For input parameters, the value of this field should be "in". For
output parameters, the value of this field should be "out". For parameters
that both serves as input and output, the value of this field should be
"in_out". Note that in C,
output parameters need to have their address taken as arguments are
passed by value. Tyrell can automatically handle the address taking part and
therefore the user does not need to manually specify a pointer type. For
example, a C function ~f~ that has one output parameter of type ~int~ will have the
following signature in C:
#+BEGIN_SRC c
void f(int*);
#+END_SRC
Here is the same function translated into Tyrell specification:
#+BEGIN_SRC toml
[[api]]
name = "f"
  [[api.param]]
  type = "int"
  direction = "out"
#+END_SRC
Note that the type of the output parameter is ~int~, not ~int*~.

/WARNING/: Currently we do not offer support for in_out array parameters due
to aliasing considerations.

*** The ~name~ field

This (optional) field specifies the name of the parameter. If left blank, a
default name will be assigned to the parameter. Within a function, parameters
should be uniquely identified by their names. Different functions are permitted
to have parameters of the same name

Currently parameter names are not used anywhere internally in the Tyrell
tool. This may change in the future.

*** The ~fixedValue~ field

If one need to pass a constant value to a parameter, he can explicitly
specify the ~fixedValue~ field of the parameter. It works like a hard equality
constraint: parameters with an explicitly specified ~fixedValue~ field will
always get the same value. 

*** Parameter index

Each parameter gets an implicitly assigned index, depending on where it appears
in the parameter specification list. For example,
#+BEGIN_SRC toml
[[api]]
name = "f"
  [[api.param]]
  type = "int"
  name = "foo"
  direction = "in"
  [[api.param]]
  type = "int"
  name = "bar"
  direction = "out"
  [[api.param]]
  type = "string"
  name = "baz"
  direction = "in"
#+END_SRC
Here we have three parameters. The first one ~foo~ will have index 0, the
second one ~bar~ will have index 1, and the third one ~baz~ will have
index 2. Parameter indices will be used in the constraint section to uniquely
identify a parameter.

(TODO: use parameter name as identifier instead?)

* The ~[[constraint]]~ section

This section contains information of all hard constraints passed down to the
synthesizer. The specification file may contain arbitrarily many constraints, each
of can be put into a separate ~[[constraint]]~ table. For example:
#+BEGIN_SRC toml
[[constraint]]
type = "HappensBefore"
api0 = "foo"
api1 = "bar"

[[constraint]]
type = "AtLeast"
api = "baz"
count = 1
#+END_SRC
The above specification contains two constraints. The first constraint says that
function ~foo~ must be invoked before function ~bar~, while the second
constraint says that function ~baz~ must be invoked at least once.

Each constraint table must start with a ~type~ field that defines what kind of
constraint it describes. Tyrell parser will first read this field and then
determines what other fields to read. Currently the following constraint types
are recognized (case insensitive):

- "HappensBefore"
- "HappensAfter"
- "AtLeast"
- "AtMost"
- "ValueConsume"
- "ValueDep"
- "ValueCmp"
- "ValueCmp2"

** The ~HappensBefore~ and ~HappensAfter~ constraint
   
These two constraints require two additional fields to be presented in the
constraint table: "api0" and "api1". Those two fields should contain the name of
two functions. If the ~HappensBefore~ constraint is presented, then in the
generated program whenever "api0" function is called there must be a call to
"api1" function before it. If the ~HappensAfter~ constraint is presented, then in the
generated program whenever "api0" function is called there must be a call to
"api1" function after it.

** The ~AtLeast~ and ~AtMost~ constraint

These two constraints require two additional fields to be presented in the
constraint table: "api" and "count". The "api" field should contain the name of
a function, and the "count" field should be an integer. If the ~AtLeast~
constraint is presented, then in the generated program function "api" will be
invoked at least "count" times. If the ~AtMost~ constraint is presented, then in
the generated program function "api" will be invoked at most "count" times.

** The ~ValueConsume~ constraint
   
The constraint requires three additional fields to be presented in the
constraint table: "api", "index", and "count". The "api" field should
contain the name of a function, and the "index" and "count" field should be
integers. If the ~ValueConsume~ constraint is presented, then in the
generated program the "index"-th parameter of function "api" must be used
"count" times by other APIs. 

Tyrell parser will reject the specification if the specified parameter is not an
output parameter. By convention, parameter index -1 refers to the return value
of a function.

** The ~ValueDep~ constraint

The constraint requires four additional fields to be presented in the constraint
table: "api0", "index0", "api1" and "index1". The "api0" and "api1"
field should both contain the name of a function, and the "index0" and "index1"
field should be integers. If the ~ValueDep~ constraint is presented, then in
the generated program the "index0"-th parameter of function "api0" must be
used by the "index1"-th parameter of function "api1".

Tyrell parser will reject the specification if the parameter specified by "api0"
and "index0" is not an output parameter, and if the parameter specified by
"api1" and "index1" is not an input parameter. By convention, parameter index -1
refers to the return value of a function. The parser will also complain if
the types of the two parameters are not the same.

** The ~ValueCmp~ constraint

The constraint requires five additional fields to be presented in the constraint
table: "api", "index", "operator", and "const". The "api" field should be the
name of a function. The "index" field should be an integer. The "constValue"
should be the value of a constant. The "operator" should be one of the string
literals listed below:
- "=="
- "!="
- "<="
- "<"
- ">="
- ">"
  
If the ~ValueCmp~ constraint is presented, then in the generated program the
"index"-th parameter of function "api", when compared to "constValue", must
satisfy the constraint specified by "operator". For example,
#+BEGIN_SRC toml
[[type]]
name = "int"
domain = [ "1", "2", "3" ]

[[api]]
name = "foo"
  [[api.param]]
  direction = "in"
  type = "int"

[[constraint]]
type = "ValueCmp"
api = "foo"
index = 0
operator = ">="
const = "2"
#+END_SRC
The above constraint says that the first parameter of function ~foo~ must be
greater than or equal to constant 2.

Tyrell parser will reject the specification if the parameter specified by "api"
and "index" is not an input parameter. By convention, parameter index -1
refers to the return value of a function. The parser will also complain if the
specified constant does not belong to the domain of the corresponding parameter
type. Finally, operators other than "==" and "!=" are only supported for
integer-like constants. 

** The ~ValueCmp2~ constraint

The constraint requires five additional fields to be presented in the constraint
table: "api0", "index0", "api1", "index1", "operator". The "api0" and "api1"
field should both contain the name of a function, and the "index0" and "index1"
field should be integers. The "operator" should be one of the string literals
listed below:
- "=="
- "!="
- "<="
- "<"
- ">="
- ">"

If the ~ValueDep~ constraint is presented, then in the generated program the
"index0"-th parameter of function "api0", when compared to the "index1"-th
parameter of function "api1", must satisfy the constraint specified by
"operator". For example, 
#+BEGIN_SRC toml
[[type]]
name = "int"
domain = [ "1", "2", "3" ]

[[api]]
name = "foo"
  [[api.param]]
  direction = "in"
  type = "int"
[[api]]
name = "bar"
  [[api.param]]
  direction = "in"
  type = "int"

[[constraint]]
type = "ValueCmp2"
api0 = "foo"
index0 = 0
api1 = "bar"
index1 = 0
operator = "=="
#+END_SRC
The above constraint says that the first parameter of function ~foo~ must be the
same as the first parameter of function ~bar~.

Tyrell parser will reject the specification if the parameter specified by "api0"
and "index0" is not an input parameter, and if the parameter specified by "api1"
and "index1" is not an input parameter. By convention, parameter index -1 refers
to the return value of a function. The parser will also complain if the types
 of the two parameters are not the same. Operators other than "==" and "!="
 are only supported for integer-like constants.
