#+TITLE: Data Wrangling Motivating Example
#+OPTIONS: toc:nil
#+OPTIONS: html-postamble:nil
#+LANGUAGE: en

This document contains a motivating example solved by the Tyrell synthesizer.

* Type list:
    - IntType
    - TableType
    - AggrType
    - ListType
    - ColIndexType
    - ConstType
    - BoolFunctionType
    - NumFunctionType

* DSL (Symbols on the left hand side denote return types):
    - Rule #1: [AggrType] -> ["mean" | "min" | "sum" | "count" ]
    - Rule #2: [BoolFunctionType] -> [ "!=" | "==" | ">" | "<" ]
    - Rule #3: [NumFunctionType] -> [ "/" | "+" | "-" | "*" ]
    - Rule #4: [TableType] -> (select) [TableType, ListType] 
    - Rule #5: [TableType] -> (group_by) [TableType, ListType] 
    - Rule #6: [TableType] -> (inner_join) [TableType, TableType] 
    - Rule #7: [TableType] -> (gather) [TableType, ListType] 
    - Rule #8: [TableType] -> (spread) [TableType, ColIndexType, ColIndexType] 
    - Rule #9: [TableType] -> (unite) [TableType, ColIndexType, ColIndexType] 
    - Rule #10: [TableType] -> (summarise) [TableType, AggrType, ColIndexType] 
    - Rule #11: [TableType] -> (separate) [TableType, ColIndexType] 
    - Rule #12: [TableType] -> (filter) [TableType, BoolFunctionType, ColIndexType, ConstType] 
    - Rule #13: [TableType] -> (mutate) [TableType, NumFunctionType, ColIndexType, ColIndexType] 
    - Rule #14: [ConstType] -> [ 0 | ... | 9 ]
    - Rule #15: [ColIndexType] -> [ 0 | ... | 5 ] (Will be bounded by the size of the table)


* Happens-before (Soft)
    - hb(#2, #3, score): The invocation of #2 happens before #3 with a confidence score of `score`

* Value Dependence (hard)
    - vd(#1, #2, score): the return value of method #1 is consumed by invocation #2 (confidence = score)

* Value Consumption (hard)
    - vc(#1, score): the return value of invocation #1 needs to be consumed at least once (confidence = score)

* Value Constraint (hard)
    - valCstParam(#4, 2) = 12: the 2nd argument of method #4 is assigned 12
    - valCstParam(#4, col(1), 3, '>=') : the 1st argument of #4 is a table, and its column number is greater or equal to the value of the 3rd argument of type ColIndexType. 
    - valCstParam(#4, col(1), max(3), '>=') : the 1st argument of #4 is a table, and its column number is greater or equal to the max element of the 3rd argument of type ListType. 
    - valCstParam(#3, -1) = (3, 4)  : the return value of invocation #3 is a table of 3 rows and 4 columns
    - valCstParam(#3, 1) = (5, 6)  : the first parameter of invocation #3 is a table of 5 rows and 6 columns

* Value Choice (Soft)
    - valCParam(#1, 1) \in [1, 2]: for the first argument of #1, its values can be either 1 or 2

Now the goal is to synthesize the following program:

#+BEGIN_SRC c


--------------------------------------------------------------------------------
| Input-Output Example                                                          |
--------------------------------------------------------------------------------

Input:

   round var1 var2 nam        val
1 round1   22   33 foo 0.16912201
2 round2   11   44 foo 0.18570826
3 round1   22   33 bar 0.12410581
4 round2   11   44 bar 0.03258235

Output:

  nam val_round1 val_round2 var1_round1 var1_round2 var2_round1 var2_round2
1 bar  0.1241058 0.03258235          22          11          33          44
2 foo  0.1691220 0.18570826          22          11          33          44

    R program:

    TBL_3=gather(p1_input1, [1, 2, 4])
    TBL_1=unite(TBL_3, [2, 0])
    morpheus=spread(TBL_1, 0, 2)
#+END_SRC
