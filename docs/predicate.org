#+TITLE: Tyrell Predicate Collection
#+OPTIONS: toc:nil
#+OPTIONS: html-postamble:nil
#+LANGUAGE: en

This document contains a list of high-level descriptions of all predicates used
in the Tyrell synthesizer.

* Happens-Before
   - [ ] Implemented
   - Type: Soft
   - Arity: 2
This predicate puts a constraint on the ordering of API calls. 

If =HappensBefore(foo, bar)= is true, then in the generated program whenever
=bar= is called, there must be a call to =foo= before it.

TODO: Do we need a "Happens-After" predicate which says if there is a =foo= then
it must be followed by a =bar=?

TODO: Extend this predicate to allow =bar= to pair up with only one preceding =foo=.

* Value Dependence
   - [ ] Implemented
   - Type: Hard
   - Arity: 2 
This predicate determines the relationship between the output parameter of one
API call and the input parameter of another API call.

If =ValueDependence(Param(foo, 1), Param(bar, 2))= is true, then in the
generated program whenever =bar= is called, its second parameter must be the
same as the first parameter of a preceding call to =foo= [fn:param]. Note that there is
an implicit requirement with this predicate: for =ValueDependence(A, B)= we
always assume that =A= is an input parameter and =B= is an output parameter.

[fn:param] Here function =Param(fun, index)= represents the =index=-th parameter
of function =fun=. We treat return values and formal parameters uniformly by
viewing the return value as the 0-th parameter.

TODO: Handle address-taking/dereference operator in C/C++

* Value Consumption
   - [ ] Implemented
   - Type: Hard
   - Arity: 1
This predicate specifies the existence of value dependence.

If =ValueConsumption(Param(foo, 0))= is true, then in the generated program
whenever =foo= is called, its return value must be consumed by at least one
other function. 

TODO: Add another predicate saying that a return value must be consumed by at
least /k/ other function?

TODO: Add another predicate saying that a return value must be consumed by /at
most/ k other function?

* Value Constraint
  - [ ] Implemented
  - Type: Hard or Soft
  - Arity: 2
This is just a conventional binary relational operator over input parameters and
constants. Support for the following relation operators is currently required:
+ Equality/Inequality over integers or strings
  e.g. =Param(foo, 1) = 2=
+ Less-than/Greater-than/Less-than-or-equal-to/Greater-than-or-equal-to over integers
  e.g. =Param(foo, 1) > Param(foo, 2)=

TODO: Do we want to allow additional arithmetic operations, e.g. =Param(f, 0) + Param(f, 1) < 2=?

* Value Choice
  - [ ] Implemented
  - Type: Soft
The predicate =ValueChoice(P, S)= asserts that we want to try parameter =P= with
every single value contained in set =S=. 

This predicate can simply be desugared into a list of equality constraints. For
example, having one value choice predicate =ValueChoice(Param(foo, 1), {2, 3,
4})= is equivalent to having three equivalence predicates =Param(foo, 1) = 2=,
=Param(foo, 1) = 3=, and =Param(foo, 1) = 4=. 

TODO: Obviously desugaring into equality constraints can be really inefficient
(enumeration time explode from O(N) to O(2^N)). We need to find a way to address
this in the future.
